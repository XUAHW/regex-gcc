# 正则表达式 + GCC编译选项综合文档

### 1.正则表达式

##### Part 1 基本概念

* **正则表达式** 是一个字符串，其中包含普通字符（如字母和数字）和特殊字符（元字符），用于定义一个搜索模式
* 它广泛应用于各种编程语言、文本编辑器和命令行工具中，如JavaScript、Python、grep等



##### Part 2 主要用途

- **搜索**：在大量文本中查找符合特定模式的字符串
- **验证**：检查字符串是否符合特定格式，如邮箱地址、电话号码的格式验证
- **替换**：根据模式替换文本，例如批量修改文档中的某些部分
- **提取**：从文本中提取符合模式的信息，如从网页中抓取链接



##### Part 3 元字符

正则表达式元字符是一组具有特殊意义的字符，它们在正则表达式中不表示自己字面上的字符，而是用来控制匹配规则的逻辑和行为 

* **重复限定符**

  1. *: 匹配前面的子表达式零次或多次

     `\d* 可以匹配任何数字组成的字符串，包括空字符串。例如，“123”，“”，“000”`

     

  2. +: 匹配前面的子表达式一次或多次

     `[a-z]+ 会匹配至少一个小写字母，如“hello”，但不匹配空字符串`

     

  3. ?: 匹配前面的子表达式零次或一次

     `colou?r 匹配“color”或“colour”，表示“u”可以出现也可以不出现`

     

  4. {m}: 精确匹配m次

     `\d{3} 仅匹配三个数字，如“123”，但不匹配“12”或“1234”`

     

  5. {m,n}: 匹配前面的子表达式至少m次，但不超过n次

     `[A-Z]{2,4} 匹配2到4个大写字母，如“AB”，“ABC”，“ABCD”，但不匹配单个字母或超过四个字母的字符串`

​	

* **位置匹配**

  1. ^: 在模式开始处匹配，如果在方括号内，则表示取反

     `^Hello 在多行模式下，匹配每行开头为“Hello”的行`

     

  2. $: 在模式结束处匹配

     `world$ 在多行模式下，匹配每行结尾为“world”的行`

     

  3. \b: 匹配单词边界

     `\bthe\b 只匹配独立的单词“the”，不匹配“there”中的“the”`

     

  4. \A: 匹配字符串的开始

     `\AStart 确保整个字符串从“Start”开始`

     

  5. \Z: 匹配字符串的结束，或在行尾前的结束

     `在多行模式下，End\Z 确保字符串或每行的结束是“End”`

     

* **字符集与否定**

  1. \[abc]: 匹配任何一个在方括号内的字符

     `[abc]at 匹配“cat”，“bat”，“cat”`

     

  2. \[^abc]: 匹配任何不在方括号内的字符

     `[^abc]at 匹配除了“a”、“b”、“c”之外的任何字符紧跟“at”，如“dat”`

     

  3. \[0-9]: 等同于\d，匹配数字

     `等同于\d，[0-9]{2} 匹配任意两位数字，如“12”`

     

  4. \[a-zA-Z]: 匹配任何字母

     `匹配任何单个字母，如“a”到“z”或“A”到“Z”`

     

* **特殊字符**

  1. .: 匹配除换行符之外的任意单个字符

     `. 匹配除换行符外的任意字符，.com 会匹配任何以“.com”结尾的字符串，如“example.com”`

     

  2. \: 用于转义特殊字符，使其失去特殊含义，如\.匹配点号本身

     `\. 匹配点号本身，而不是任何字符，如\.\d匹配点后跟着数字，如“1.2”`

     

  3. |: 用于选择，表示“或”，匹配左边或右边的表达式之一

     `red|blue 匹配“red”或“blue”`

     

* **分组与引用**

  1. ( ): 分组，将括号内的表达式作为整体处理，也可以用于后向引用

     `(abc)\1 匹配“abcabc”，其中\1引用第一个括号内的内容`

     

  2. \1, \2, ...: 引用前面分组的内容，用于重复匹配
     `(.\d+)(.\d+)\2\1 匹配两个数字序列并确保它们按相同的顺序重复，如“12321”`

     

* **前瞻与后顾**

  1. (?=...): 正向前瞻，确保后面跟的是...但不消耗字符

     `word(?=ing) 匹配“word”仅当其后紧跟“ing”，但不包括“ing”`

     

  2. (?!...): 负向前瞻，确保后面不跟的是...

     `word(?!ing) 匹配“word”但不匹配其后紧跟“ing”的情况`

     

  3. (?<=...): 正向后顾，确保前面是...但不消耗字符

     `(?<=\d)th 匹配任何数字后的“th”，确保“th”前有数字，但不包括数字`

     

  4. (?<!...): 负向后顾，确保前面不是...

     `(?<!\d)th 匹配“th”，但确保它前面不是数字`

     

##### Part 4 正则表达式的贪婪匹配与惰性匹配

* **贪婪匹配**

  贪婪匹配是正则表达式默认的行为模式，它尽可能多地匹配字符。当正则表达式中的量词（如*、+、?、{n,}等）遇到可匹配的字符时，会尽可能地扩展匹配范围，直到无法继续匹配为止。如果后续的模式无法匹配，正则引擎会逐步回溯，撤销之前的部分匹配，直到找到一个合适的匹配

  

  **示例**: 假设我们有字符串 "hello world"，并使用正则表达式 /lo+/ 来匹配 "lo" 后面跟着尽可能多的字符

  * **贪婪匹配**: 正则表达式会匹配到 "llo world"，因为+是贪婪的，它尽可能多地匹配 "l" 后面的字符，直到不能匹配为止

    

* **惰性匹配**

  惰性匹配，也称为非贪婪匹配或懒惰求值，与贪婪匹配相反，它尽可能少地匹配字符。在量词后面加上问号 ? 可以使量词变为惰性。这意味着它会匹配尽可能少的字符，仅匹配刚好满足整个正则表达式要求的字符数量

  

  **示例**: 使用相同的字符串 "hello world"，但这次我们使用惰性匹配的正则表达式 /lo+?/

  - **惰性匹配**: 正则表达式将只匹配到 "lo"，因为+?会尽可能少地匹配字符，仅匹配到第一个满足条件的实例

    

### 2.GCC编译选项

##### Part 1 基本概念

* gcc是GNU Complier Collection的缩写。最初是作为C语言的编译器，现在已经支持多种语言，如C、C++、Java语言等

* gcc是一个可移植的编译器，支持多种硬件平台。

* gcc不仅仅是个本地编译器，它还能跨平台交叉编译。

* gcc有多种语言前前端，用于解析不同的语言。

* gcc是按模块化设计的，可以加入新语言和新CPU架构的支持。

* gcc是自由软件

  

##### Part 2 编译流程

1. 预处理
2. 编译
3. 汇编
4. 链接



##### Part 3 编译选项

* 选项详细信息

  | 选项名 | 作用                                                         |
  | ------ | ------------------------------------------------------------ |
  | -o     | 产生目标                                                     |
  | -c     | 通知gcc取消链接步骤，即编译源码并在最后生成目标文件          |
  | -E     | 只运行C预编译器                                              |
  | -S     | 告诉编译器产生汇编语言文件后停止编译，产生的汇编语言文件扩展名为.s |
  | -Wall  | 使gcc对源代码的代码有问题的地方发出警告                      |
  | -Idir  | 将dir目录加入搜索头文件的目录路径                            |
  | -Ldir  | 将dir目录加入搜索库的目录路径                                |
  | -llib  | 链接lib库                                                    |
  | -g     | 在目标文件中嵌入调试信息，以便gdb之类的调试程序调试          |

  



* gcc应用示例

  ```bash
  gcc -E hello.c -o hello.i #预处理
  gcc -S hello.i -o hello.s #编译
  gcc -c hello.s -o hello.o #汇编
  gcc hello.o -o hello #链接
  
  gcc hello.c -o hello #直接编译链接成可执行目标文件
  gcc -c hello.c 或 gcc -c hello.c -o hello.o #编译生成可重定位目标文件
  ```

  

* gcc编译多文件

  ```bash
  hello_fn.h
  hello_fn.c
  main.c
  
  #一次性编译
  gcc hello_fn.c main.c -o newhello
  
  #独立编译
  gcc -Wall -c main.c -o main.o
  gcc -Wall -c hello_fn.c -o hello_fn.o
  gcc -Wall main.o hello_fn.o -o newhello
  ```

  

* 使用外部库

  ```c++
  //calc.c
  #include <math.h>
  #include <stdio.h>
  
  int main()
  {
      double x = pow(2.0, 3.0);
      printf("The cubed if %f\n", x);
      return 0;
  }
  ```

  ```bash
  gcc -Wall calc.c -o calc -lm
  # -lm 表示要链接libm.so或者libm.a库文件
  ```

  

